-module(nnerl_lib).

-compile(export_all).


%
% --- for loop with funs. Returns a list with elements
%     generated by GeneratorF().
%
forf(Start, ContinueF, IncDecF, GeneratorF) ->
	forf(Start, ContinueF, IncDecF, GeneratorF, []).
forf(Start, ContinueF, IncDecF, GeneratorF, Lacc) ->
	case ContinueF(Start) of
		true -> forf(IncDecF(Start), ContinueF, IncDecF, 
			GeneratorF, [GeneratorF(Start) | Lacc]);
		false -> lists:reverse(Lacc)
	end,
	true.


%
% --- Represent directed graphs without using ets.
%     Does not require serialization to unconsult().
%
digraph_new() -> {nnerl_lib, digraph, #{}}.

% --- uses stateful module technique, so it appears
%     tp the user as new_vertex/1 and new_vertex/2.
new_vertex(Vertex, DigraphTuple) ->
	new_vertex(Vertex, undefined, DigraphTuple).
new_vertex(Vertex, Label, {nnerl_lib, digraph, AdjacencyMap}) ->
	{nnerl_lib, digraph, AdjacencyMap#{Vertex => {Label, #{}}}}.

% --- uses stateful module technique, so it appears
%     tp the user as new_edge/1 and new_edge/2.
new_edge(V1, V2, {nnerl_lib, digraph, AdjacencyMap}) ->
	new_edge(V1, V2, undefined, {nnerl_lib, digraph, AdjacencyMap}).
 new_edge(V1, V2, EdgeLabel, {nnerl_lib, digraph, AdjacencyMap}) ->
	case maps:is_key(V1, AdjacencyMap) and maps:is_key(V2, AdjacencyMap) of
		true ->
			{VertexLabel, EdgeMap} = maps:get(V1, AdjacencyMap),
			NewEdgeMap = EdgeMap#{V2 => EdgeLabel},
			{nnerl_lib, digraph, AdjacencyMap#{V1 := {VertexLabel, NewEdgeMap}}};
		false ->
			erlang:error(unkown_vertex)
	end.


%
% --- Serializes a digraph created by the digraph module, which uses ets.
%     Note: this does not work for digraphs created by nnerl_lib.
%
serialize_digraph(Graph) ->
	sofs:digraph_to_family(Graph).

unserialize_digraph(Family) ->
	sofs:family_to_digraph(Family).



%
% --- unconsults, that is writes a file readable by consult()
%
unconsult(Path, Data) ->
	file:write_file(Path, io_lib:fwrite("~p.\n", Data)).

%
% --- zipper lists to emulate doubly linked lists, with the notion
%     of a current element pointer.
%
list_to_zlist(L) when is_list(L) -> {[], L}.
zlist_to_list({nnerl_lib, zlist, Pre, Post}) -> lists:reverse(Pre) ++ Post.

zcurrent({nnerl_lib, zlist, _, [Current|_]}) -> Current.

zprev({nnerl_lib, zlist, [H|T], Post}) -> {nnerl_lib, zlist, T, [H|Post]}.

znext({nnerl_lib, zlist, Pre, [H|T]}) -> {nnerl_lib, zlist, [H|Pre], T}.

zset({nnerl_lib, zlist, Value, {Pre, [_|Post]}}) -> {nnerl_lib, zlist, Pre, [Value|Post]}.

zinsert(Value, {nnerl_lib, zlist, Pre, Post}) -> {nnerl_lib, zlist, Pre, [Value|Post]}.

zdelete({nnerl_lib, zlist, Pre, [_|Post]}) -> {nnerl_lib, zlist, Pre, Post}.

