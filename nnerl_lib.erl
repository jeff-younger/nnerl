-module(nnerl_lib).

-compile(export_all).


%
% --- for loop with funs. Returns a list with elements
%     generated by GeneratorF().
%
-spec forf(term(), fun((term()) -> boolean()), 
	fun((term()) -> term()), fun((term()) -> term())) -> list().

forf(Start, ContinueF, IncDecF, GeneratorF) ->
	forf(Start, ContinueF, IncDecF, GeneratorF, []).
forf(Start, ContinueF, IncDecF, GeneratorF, Lacc) ->
	case ContinueF(Start) of
		true -> forf(IncDecF(Start), ContinueF, IncDecF, 
			GeneratorF, [GeneratorF(Start) | Lacc]);
		false -> lists:reverse(Lacc)
	end.


%
% --- Represent directed graphs without using ets.
%     Does not require serialization to unconsult().
%
-type digraph_tuple() :: {nnerl, digraph, map()}.

-spec digraph_new() -> digraph_tuple().

digraph_new() -> {nnerl_lib, digraph, #{}}.

% --- uses stateful module technique, so it appears
%     tp the user as new_vertex/1 and new_vertex/2.
-spec new_vertex(term(), digraph_tuple()) -> digraph_tuple().

new_vertex(Vertex, DigraphTuple) ->
	new_vertex(Vertex, undefined, DigraphTuple).

-spec new_vertex(term(), term(), digraph_tuple()) -> digraph_tuple().

new_vertex(Vertex, Label, {nnerl_lib, digraph, AdjacencyMap}) ->
	{nnerl_lib, digraph, AdjacencyMap#{Vertex => {Label, #{}}}}.

% --- uses stateful module technique, so it appears
%     tp the user as new_edge/1 and new_edge/2.
-spec new_edge(term(), term(), digraph_tuple()) -> digraph_tuple().

new_edge(V1, V2, {nnerl_lib, digraph, AdjacencyMap}) ->
	new_edge(V1, V2, undefined, {nnerl_lib, digraph, AdjacencyMap}).

-spec new_edge(term(), term(), term(), digraph_tuple()) -> digraph_tuple().

new_edge(V1, V2, EdgeLabel, {nnerl_lib, digraph, AdjacencyMap}) ->
	case maps:is_key(V1, AdjacencyMap) and maps:is_key(V2, AdjacencyMap) of
		true ->
			{VertexLabel, EdgeMap} = maps:get(V1, AdjacencyMap),
			NewEdgeMap = EdgeMap#{V2 => EdgeLabel},
			{nnerl_lib, digraph, AdjacencyMap#{V1 := {VertexLabel, NewEdgeMap}}};
		false ->
			erlang:error(unkown_vertex)
	end.


%
% --- Serializes a digraph created by the digraph module, which uses ets.
%     Note: this does not work for digraphs created by nnerl_lib.
%
-spec serialize_digraph(digraph:graph()) -> sofs:family().

serialize_digraph(Graph) ->
	sofs:digraph_to_family(Graph).

-spec unserialize_digraph(sofs:family()) -> digraph:graph().

unserialize_digraph(Family) ->
	sofs:family_to_digraph(Family).



%
% --- unconsults, that is writes a file readable by consult()
%
-spec unconsult(string(), term()) -> ok | {error, term()}.
unconsult(Path, Data) ->
	file:write_file(Path, io_lib:fwrite("~p.\n", Data)).

%
% --- zipper lists to emulate doubly linked lists, with the notion
%     of a current element pointer.
%
-type zlist() :: {nnerl_lib, zlist, list(), list()}.

-spec list_to_zlist(list()) -> zlist().
list_to_zlist(L) when is_list(L) -> {nnerl_lib, zlist, [], L}.

-spec zlist_to_list(zlist()) -> list().
zlist_to_list({nnerl_lib, zlist, Pre, Post}) -> lists:reverse(Pre) ++ Post.

-spec zat(zlist()) -> term().
zat({nnerl_lib, zlist, _, [Current|_]}) -> Current.

-spec zprev(zlist()) -> zlist().
zprev({nnerl_lib, zlist, [H|T], Post}) -> {nnerl_lib, zlist, T, [H|Post]}.

-spec znext(zlist()) -> zlist().
znext({nnerl_lib, zlist, Pre, [H|T]}) -> {nnerl_lib, zlist, [H|Pre], T}.

-spec zset(term(), zlist()) -> zlist().
zset(Value, {nnerl_lib, zlist, Pre, [_|Post]}) -> {nnerl_lib, zlist, Pre, [Value|Post]}.

-spec zins(term(), zlist()) -> zlist().
zins(Value, {nnerl_lib, zlist, Pre, Post}) -> {nnerl_lib, zlist, Pre, [Value|Post]}.

-spec zdel(zlist()) -> zlist().
zdel({nnerl_lib, zlist, Pre, [_|Post]}) -> {nnerl_lib, zlist, Pre, Post}.

